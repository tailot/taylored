diff --git a/lib/handlers/buy-handler.ts b/lib/handlers/buy-handler.ts
new file mode 100644
index 0000000..22d5868
--- /dev/null
+++ b/lib/handlers/buy-handler.ts
@@ -0,0 +1,460 @@
+import * as fs from 'fs-extra';
+import * as path from 'path';
+import * as https from 'https';
+import { validateTaysellFileContent, TaysellFile } from '../taysell-utils';
+import { TAYLORED_DIR_NAME, TAYLORED_FILE_EXTENSION } from '../constants';
+//import { handleApplyOperation } from '../apply-logic';
+import { printUsageAndExit } from '../utils';
+import * as crypto from 'crypto';
+import inquirer from 'inquirer';
+
+/**
+ * Polls a server endpoint to check for purchase confirmation and retrieve a purchase token.
+ *
+ * This function repeatedly makes GET requests to a specified `checkUrl` (appended with
+ * `cliSessionId`) until the server responds with a valid `purchaseToken` and a matching
+ * `patchId`, or until a timeout occurs. It handles various HTTP status codes,
+ * retrying on transient issues (like 404 or other client-side errors) and failing fast
+ * on definitive server errors (5xx or >405). Warnings are logged to the console
+ * periodically if polling continues without success, to avoid spamming.
+ *
+ * @async
+ * @param {string} checkUrl - The base URL of the server endpoint to poll for purchase status.
+ * @param {string} cliSessionId - The unique session ID generated by the CLI to link
+ *                                this polling session with the browser-based payment process.
+ * @param {string} patchIdToVerify - The expected Patch ID. The server's response must include
+ *                                   this ID for the polling to be considered successful.
+ * @param {number} [timeoutMs=600000] - Total time in milliseconds to continue polling before timing out.
+ *                                      Defaults to 10 minutes.
+ * @param {number} [intervalMs=2500] - Interval in milliseconds between polling attempts.
+ *                                     Defaults to 2.5 seconds.
+ * @returns {Promise<{ patchId: string; purchaseToken: string }>} A promise that resolves with an
+ *          object containing the `patchId` and `purchaseToken` upon successful confirmation.
+ * @throws {Error} Throws an error if:
+ *                 - Polling times out.
+ *                 - The server returns a terminal error status (e.g., 5xx).
+ *                 - The server responds successfully but with an invalid/unexpected data structure.
+ */
+async function pollForToken(
+  checkUrl: string,
+  cliSessionId: string,
+  patchIdToVerify: string,
+  timeoutMs: number = 600000,
+  intervalMs: number = 2500,
+): Promise<{ patchId: string; purchaseToken: string }> {
+  const startTime = Date.now();
+  console.log(
+    `CLI: Starting polling for purchase token for session ${cliSessionId}. Timeout: ${timeoutMs / 1000}s.`,
+  );
+  let lastWarningTime = 0;
+  const WARNING_INTERVAL = 15000; // ms, to avoid spamming warnings
+
+  while (Date.now() - startTime < timeoutMs) {
+    try {
+      const fullUrl = `${checkUrl}/${cliSessionId}`;
+      const response = await new Promise<{
+        statusCode: number | undefined;
+        body: string;
+      }>((resolve, reject) => {
+        https
+          .get(fullUrl, (res) => {
+            let data = '';
+            res.on('data', (chunk) => (data += chunk));
+            res.on('end', () =>
+              resolve({ statusCode: res.statusCode, body: data }),
+            );
+          })
+          .on('error', (err) => reject(err)); // Network errors will be caught by the outer try-catch
+      });
+
+      if (response.statusCode === 200) {
+        const data = JSON.parse(response.body); // JSON parse errors will be caught by outer try-catch
+        if (
+          data.purchaseToken &&
+          data.patchId &&
+          data.patchId === patchIdToVerify
+        ) {
+          console.log(
+            'CLI: Purchase token and verified patch ID received successfully.',
+          );
+          return { purchaseToken: data.purchaseToken, patchId: data.patchId };
+        } else {
+          // Successful response, but unexpected data (e.g., missing token, wrong patchId)
+          if (Date.now() - lastWarningTime > WARNING_INTERVAL) {
+            console.warn(
+              `CLI: Server responded successfully (200) but with unexpected data structure at ${fullUrl}. Retrying...`,
+            );
+            lastWarningTime = Date.now();
+          }
+        }
+      } else if (response.statusCode === 404) {
+        // Changed behavior: Log a warning and retry on 404, instead of throwing immediately.
+        if (Date.now() - lastWarningTime > WARNING_INTERVAL) {
+          console.warn(
+            `CLI: Purchase session not found (404) at ${fullUrl}. Please waiting! Retrying...`,
+          );
+          lastWarningTime = Date.now();
+        }
+      } else if (
+        response.statusCode !== undefined &&
+        response.statusCode > 405
+      ) {
+        // Server errors (5xx) or other client errors (>405 and not 404)
+        // These are considered terminal for the polling process by this client.
+        const errorMessage = `Server error during polling: Status ${response.statusCode}`;
+        console.error(`CLI: ${errorMessage} at ${fullUrl}. Aborting polling.`);
+        throw new Error(errorMessage); // This will be caught by handleBuyCommand
+      } else if (response.statusCode !== 200) {
+        // For other non-200 codes not explicitly handled (e.g., 400-403, 405, or 2xx with unexpected data if previous checks failed)
+        // Log a warning and continue retrying until timeout.
+        if (Date.now() - lastWarningTime > WARNING_INTERVAL) {
+          console.warn(
+            `CLI: Unexpected response (Status: ${response.statusCode}) from server at ${fullUrl}. Retrying...`,
+          );
+          lastWarningTime = Date.now();
+        }
+      }
+    } catch (error: any) {
+      // If the error is a specific one we want to propagate immediately (404 or server error > 405), re-throw it.
+      if (
+        error.message &&
+        error.message.startsWith('Server error during polling:')
+      ) {
+        throw error;
+      }
+      // Catches network errors from https.get or JSON.parse errors
+      if (Date.now() - lastWarningTime > WARNING_INTERVAL) {
+        console.warn(
+          `CLI: Error during polling attempt: ${error.message}. Retrying...`,
+        );
+        lastWarningTime = Date.now();
+      }
+    }
+    await new Promise((resolve) => setTimeout(resolve, intervalMs));
+  }
+  // Timeout occurred
+  throw new Error(
+    'Timeout: Waited too long for purchase confirmation. If payment was made, please contact the seller.',
+  );
+}
+
+/**
+ * Displays a standardized user assistance message when a purchase-related error occurs.
+ *
+ * This function formats and logs a detailed error message to the console, guiding the user
+ * on how to proceed if their payment was potentially made but the patch acquisition failed.
+ * It includes seller contact information and relevant transaction identifiers.
+ * After displaying the message, it terminates the process with exit code 1.
+ *
+ * @param {"Timeout" | "Download Failed" | "Polling Server Error"} issueType - The type of issue encountered.
+ * @param {TaysellFile} taysellData - The parsed content of the `.taysell` file, containing
+ *                                    seller and patch information.
+ * @param {string | null} cliSessionId - The CLI session ID, relevant for timeout or polling issues.
+ * @param {string | null} purchaseToken - The purchase token, if obtained (relevant for download failures).
+ * @param {string} underlyingErrorMessage - The original error message that led to this assistance request.
+ * @returns {void} This function does not return as it exits the process.
+ */
+function displayPurchaseAssistanceMessage(
+  issueType: 'Timeout' | 'Download Failed' | 'Polling Server Error',
+  taysellData: TaysellFile,
+  cliSessionId: string | null,
+  purchaseToken: string | null,
+  underlyingErrorMessage: string,
+): void {
+  const title =
+    issueType === 'Timeout'
+      ? 'Purchase Confirmation Timed Out'
+      : issueType === 'Download Failed'
+        ? 'Payment Succeeded, Download Failed'
+        : 'Server Error During Purchase Confirmation';
+  console.error(`\n--- ${title} ---`);
+
+  if (issueType === 'Timeout') {
+    console.error(
+      'We were unable to confirm your purchase within the time limit.',
+    );
+    console.error('This could be due to several reasons:');
+    console.error('  - The payment process was not completed in the browser.');
+    console.error(
+      '  - There was a network issue preventing communication with the server.',
+    );
+    console.error("  - The seller's server is experiencing delays.");
+  } else if (issueType === 'Polling Server Error') {
+    console.error(
+      "The seller's server reported an issue while we were trying to confirm your purchase status.",
+    );
+    console.error(
+      'This might be a temporary problem with the server or an issue with the purchase session.',
+    );
+    console.error('Details of the error encountered:');
+    // The underlyingErrorMessage will contain the status code from the server.
+    console.error(`  ${underlyingErrorMessage}`);
+  } else {
+    console.error(
+      'An error occurred while attempting to download the patch after your payment was processed.',
+    );
+  }
+  console.error(
+    '\nIf you believe your payment was successful (or in case of download failure), please contact the seller for assistance.\n',
+  );
+
+  const sellerContact = taysellData.sellerInfo.contact;
+  const patchName = taysellData.metadata.name;
+
+  console.error(`Seller Contact: ${sellerContact}\n`);
+  console.error(
+    'Please provide them with the following information if you contact them:\n',
+  );
+  console.error(
+    `- Issue: ${issueType} for patch "${patchName}" (Patch ID: ${taysellData.patchId}).`,
+  );
+  if (cliSessionId) console.error(`- CLI Session ID: ${cliSessionId}`);
+  if (purchaseToken) console.error(`- Purchase Token: ${purchaseToken}`);
+  console.error('\n---------------------------\n');
+  console.error(`CRITICAL ERROR: ${underlyingErrorMessage}`); // Display the original error that led to this
+  process.exit(1);
+}
+
+/**
+ * Implements the `taylored --buy <file.taysell> [--dry-run]` command.
+ *
+ * This function orchestrates the process of purchasing a commercial Taylored patch.
+ * The workflow includes:
+ * 1.  **File Validation**: Reads and validates the provided `.taysell` metadata file.
+ *     Ensures required fields (endpoints, patchId) are present and `getPatchUrl` uses HTTPS.
+ * 2.  **User Confirmation**: Prompts the user (unless in a test environment) to confirm
+ *     the purchase, displaying patch name and seller information.
+ * 3.  **Payment Initiation**:
+ *     - Generates a unique `cliSessionId`.
+ *     - Constructs the payment URL from `endpoints.initiatePaymentUrl` in the `.taysell` file,
+ *       appending the `cliSessionId`.
+ *     - Opens this URL in the user's default web browser for payment processing.
+ * 4.  **Payment Confirmation Polling**:
+ *     - Calls `pollForToken` to repeatedly query the seller's Taysell server
+ *       (at `SERVER_BASE_URL/check-purchase/:cliSessionId`) to wait for payment
+ *       completion and retrieve a `purchaseToken`.
+ * 5.  **Patch Download**:
+ *     - Upon receiving a valid `purchaseToken`, makes a POST request to the
+ *       `endpoints.getPatchUrl` (from `.taysell` file) with the `patchId` and `purchaseToken`.
+ *     - The server is expected to return the decrypted patch content.
+ * 6.  **Patch Handling**:
+ *     - If `isDryRun` is true: Prints the downloaded patch content to the console.
+ *     - If `isDryRun` is false:
+ *       - Saves the patch content to a new `.taylored` file in the local `.taylored/` directory
+ *         (filename derived from `patchId`).
+ *       - (Currently commented out) Would then call `handleApplyOperation` to apply the new patch.
+ * 7.  **Error Handling**: If any step fails (e.g., file validation, polling timeout, download error),
+ *     it calls `printUsageAndExit` or `displayPurchaseAssistanceMessage` to inform the user
+ *     and then typically exits the process.
+ *
+ * For more details on this command and the Taysell system, refer to `DOCUMENTATION.md`.
+ *
+ * @async
+ * @param {string} taysellFilePath - Path to the `.taysell` metadata file for the patch to be purchased.
+ * @param {boolean} isDryRun - If true, simulates the purchase and prints the patch content
+ *                             instead of saving and applying it.
+ * @param {string} CWD - The current working directory, used for resolving file paths.
+ * @returns {Promise<void>} A promise that resolves when the buy operation (or dry run) is complete,
+ *                          or if the user aborts the process.
+ * @throws {Error} This function typically handles its own errors by calling `printUsageAndExit`
+ *                 or `displayPurchaseAssistanceMessage` which terminate the process. It doesn't
+ *                 usually throw errors to be caught by the main CLI handler.
+ */
+export async function handleBuyCommand(
+  taysellFilePath: string,
+  isDryRun: boolean,
+  CWD: string,
+): Promise<void> {
+  if (!taysellFilePath.endsWith('.taysell')) {
+    printUsageAndExit(
+      `Invalid file type for '${taysellFilePath}'. Expected a .taysell file.`,
+    );
+    return;
+  }
+
+  const fullTaysellPath = path.resolve(CWD, taysellFilePath);
+  if (!(await fs.pathExists(fullTaysellPath))) {
+    printUsageAndExit(
+      `CRITICAL ERROR: Taysell file not found at: ${fullTaysellPath}`,
+    );
+    return;
+  }
+
+  let taysellData: TaysellFile;
+  try {
+    const fileContent = await fs.readFile(fullTaysellPath, 'utf-8');
+    taysellData = JSON.parse(fileContent);
+    validateTaysellFileContent(taysellData);
+  } catch (error: any) {
+    printUsageAndExit(
+      `Error reading or parsing taysell file ${taysellFilePath}: ${error.message}`,
+    );
+    return;
+  }
+
+  const { endpoints, patchId, metadata } = taysellData;
+
+  if (!endpoints?.initiatePaymentUrl || !endpoints?.getPatchUrl) {
+    printUsageAndExit(
+      'Endpoint URLs (initiatePaymentUrl or getPatchUrl) are not defined in the taysell file.',
+    );
+    return;
+  }
+  if (!patchId) {
+    printUsageAndExit('Patch ID is not defined in the taysell file.');
+    return;
+  }
+
+  const getPatchUrlObj = new URL(endpoints.getPatchUrl);
+  if (getPatchUrlObj.protocol !== 'https:') {
+    printUsageAndExit(
+      'CRITICAL ERROR: for security reasons, getPatchUrl must use HTTPS.',
+    );
+    return;
+  }
+
+  // Added to avoid prompt if in test mode
+  if (!process.env.JEST_WORKER_ID) {
+    const { proceed } = await inquirer.prompt([
+      {
+        type: 'confirm',
+        name: 'proceed',
+        message: `You are about to purchase the patch "${metadata.name}" from "${taysellData.sellerInfo.name}". Continue?`,
+        default: true,
+      },
+    ]);
+    if (!proceed) {
+      console.log('Purchase aborted by user.');
+      return;
+    }
+  }
+
+  const cliSessionId = crypto.randomUUID();
+  const initiatePaymentUrlWithParams = `${endpoints.initiatePaymentUrl}?cliSessionId=${cliSessionId}`;
+
+  console.log('CLI: Opening browser for payment approval...');
+  try {
+    const { default: open } = await import('open'); // Dynamic import
+    await open(initiatePaymentUrlWithParams);
+  } catch (error) {
+    console.error(
+      'CLI: Could not open browser. Please copy and paste the following URL into your browser:',
+      error,
+    );
+    console.log(initiatePaymentUrlWithParams);
+  }
+
+  console.log('CLI: Waiting to receive purchase token from browser...');
+  let purchaseToken: string;
+
+  try {
+    const paymentApiBaseUrl = new URL(endpoints.initiatePaymentUrl).origin;
+    const checkUrl = `${paymentApiBaseUrl}/check-purchase`;
+    console.log(`CLI: Starting polling to: ${checkUrl}/${cliSessionId}`);
+    const pollResult = await pollForToken(checkUrl, cliSessionId, patchId);
+    purchaseToken = pollResult.purchaseToken;
+  } catch (error: any) {
+    if (error.message && error.message.startsWith('Timeout:')) {
+      displayPurchaseAssistanceMessage(
+        'Timeout',
+        taysellData,
+        cliSessionId,
+        null, // No purchase token yet if timeout occurred during polling
+        `Timeout confirming purchase for patch "${taysellData.metadata.name}". ${error.message}`,
+      );
+      // process.exit(1) is called within displayPurchaseAssistanceMessage
+    } else if (
+      error.message &&
+      error.message.includes('Purchase session not found (404)')
+    ) {
+      // This block should ideally not be reached if pollForToken retries on 404 until timeout.
+      // However, keeping it as a fallback or if other parts of the code could throw this.
+      // The more likely scenario now is a general timeout.
+      printUsageAndExit(
+        `CLI: The purchase session was consistently not found (404) and polling timed out or was aborted.`,
+      );
+    } else if (
+      error.message &&
+      error.message.startsWith('Server error during polling:')
+    ) {
+      displayPurchaseAssistanceMessage(
+        'Polling Server Error',
+        taysellData,
+        cliSessionId,
+        null, // No purchase token if polling failed due to server error
+        `The server returned an error while confirming purchase for patch "${taysellData.metadata.name}". ${error.message}`,
+      );
+      // displayPurchaseAssistanceMessage calls process.exit(1), so this line should not be reached.
+      // The original printUsageAndExit message here was also misleading for this error type.
+    } else {
+      printUsageAndExit(
+        `CLI: An unexpected error occurred while trying to retrieve the purchase token: ${error.message}`,
+      );
+    }
+    return; // Should be unreachable
+  }
+
+  console.log(`CLI: Requesting patch from ${endpoints.getPatchUrl}...`);
+  try {
+    const postData = JSON.stringify({ patchId, purchaseToken });
+    const options = {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        'Content-Length': Buffer.byteLength(postData),
+      },
+    };
+
+    const patchContent = await new Promise<string>((resolve, reject) => {
+      const req = https.request(endpoints.getPatchUrl, options, (res) => {
+        let body = '';
+        res.on('data', (chunk) => (body += chunk));
+        res.on('end', () => {
+          if (res.statusCode !== 200) {
+            reject(
+              new Error(
+                `Failed to download patch. Status: ${res.statusCode} - ${body}`,
+              ),
+            );
+          } else {
+            resolve(body);
+          }
+        });
+      });
+      req.on('error', (e) =>
+        reject(new Error(`Error making request to get patch: ${e.message}`)),
+      );
+      req.write(postData);
+      req.end();
+    });
+
+    if (isDryRun) {
+      console.log('--- DRY RUN ---');
+      console.log('The patch will not be saved or applied.');
+      console.log('Received patch content:');
+      console.log(patchContent);
+    } else {
+      const tayloredDir = path.resolve(CWD, TAYLORED_DIR_NAME);
+      const targetFileName = `${patchId.replace(/[^a-z0-9]/gi, '_')}${TAYLORED_FILE_EXTENSION}`;
+      const destinationPath = path.join(tayloredDir, targetFileName);
+
+      await fs.ensureDir(tayloredDir);
+      await fs.writeFile(destinationPath, patchContent);
+      console.log(`Patch downloaded and saved to: ${destinationPath}`);
+
+      //await handleApplyOperation(targetFileName, false, false, "buy", CWD);
+      console.log(
+        `Purchase and application of patch '${metadata.name}' completed.`,
+      );
+    }
+  } catch (error: any) {
+    displayPurchaseAssistanceMessage(
+      'Download Failed',
+      taysellData,
+      cliSessionId, // Pass cliSessionId for completeness, though purchaseToken is more direct here
+      purchaseToken, // Purchase token is available if download failed after polling
+      `Failed to retrieve/download patch "${taysellData.metadata.name}". Details: ${error.message}`,
+    );
+    // process.exit(1) is called within displayPurchaseAssistanceMessage
+  }
+}
diff --git a/lib/handlers/create-taysell-handler.ts b/lib/handlers/create-taysell-handler.ts
new file mode 100644
index 0000000..a9ccfb8
--- /dev/null
+++ b/lib/handlers/create-taysell-handler.ts
@@ -0,0 +1,291 @@
+// Copyright (c) 2025 tailot@gmail.com
+// SPDX-License-Identifier: MIT
+
+// lib/handlers/create-taysell-handler.ts
+import * as fs from 'fs-extra';
+import * as path from 'path';
+import inquirer from 'inquirer';
+import * as crypto from 'crypto'; // For generating patchId
+import { encryptAES256GCM } from '../taysell-utils'; // Corrected path
+import { TAYLORED_FILE_EXTENSION } from '../constants'; // Assuming this exists for .taylored extension
+
+// Helper function to read .env file
+/**
+ * Reads a simple .env file and parses its key-value pairs.
+ *
+ * This function is a basic parser that assumes keys and values are separated by '='.
+ * It handles lines starting with '#' as comments and ignores empty lines.
+ *
+ * @async
+ * @param {string} envPath - The path to the .env file.
+ * @returns {Promise<Record<string, string>>} A promise that resolves to an object
+ *          containing the key-value pairs from the .env file. Returns an empty
+ *          object if the file does not exist.
+ */
+async function readEnvFile(envPath: string): Promise<Record<string, string>> {
+  if (!(await fs.pathExists(envPath))) {
+    return {};
+  }
+  const content = await fs.readFile(envPath, 'utf-8');
+  const envConfig: Record<string, string> = {};
+  content.split('\n').forEach((line) => {
+    const [key, ...valueParts] = line.split('=');
+    if (key && valueParts.length > 0) {
+      envConfig[key.trim()] = valueParts.join('=').trim();
+    }
+  });
+  return envConfig;
+}
+
+/**
+ * Implements the `taylored create-taysell <file.taylored> [--price <price>] [--desc "description"]` command.
+ *
+ * This function takes an existing `.taylored` patch file and prepares it for commercial
+ * distribution through the Taysell system. The process involves:
+ *
+ * 1.  **Validation**: Checks if the input `tayloredFilePath` is a valid `.taylored` file and exists.
+ * 2.  **Backend Configuration**: Attempts to read `SERVER_BASE_URL` and `PATCH_ENCRYPTION_KEY`
+ *     from `taysell-server/.env` located in the `cwd`. If not found, it prompts the user for them.
+ * 3.  **Interactive Prompts (via Inquirer)**: Collects metadata for the commercial patch.
+ *     This includes:
+ *     - Commercial name for the patch.
+ *     - Description (uses `descriptionInput` if provided).
+ *     - Unique Patch ID (can be auto-generated using UUIDv4 or taken from environment/input).
+ *     - Required `taylored` CLI version.
+ *     - Price (uses `priceInput` if provided).
+ *     - Currency code (e.g., USD).
+ *     - Seller information (name, website, contact email), potentially pre-filled from `.env`.
+ *     In test environments (`process.env.JEST_WORKER_ID` set), prompts are skipped, and
+ *     default/test values are used.
+ * 4.  **Patch Encryption**: Reads the content of the input `.taylored` file and encrypts it
+ *     using AES-256-GCM with the `PATCH_ENCRYPTION_KEY`. The encrypted content is saved
+ *     to a new file named `<original_basename>.taylored.encrypted`.
+ * 5.  **.taysell File Generation**: Creates a JSON metadata file (e.g., `<original_basename>.taysell`).
+ *     This file contains all commercial details, seller information, and constructed API
+ *     endpoints (`initiatePaymentUrl`, `getPatchUrl`) based on the `SERVER_BASE_URL` and `patchId`.
+ * 6.  **User Instructions**: Informs the user about the created encrypted patch and `.taysell`
+ *     metadata file, advising them to upload the encrypted patch to their Taysell server's
+ *     `patches/` directory and distribute the `.taysell` file to buyers.
+ *
+ * For more information on this command and the Taysell system, refer to `DOCUMENTATION.md`.
+ *
+ * @async
+ * @param {string} tayloredFilePath - Path to the source `.taylored` patch file to be packaged.
+ * @param {string | undefined} priceInput - Optional price provided via command-line argument.
+ * @param {string | undefined} descriptionInput - Optional description provided via command-line argument.
+ * @param {string} cwd - The current working directory. Used to resolve file paths and locate
+ *                       the `taysell-server/.env` file.
+ * @returns {Promise<void>} A promise that resolves when the Taysell package creation is complete.
+ * @throws {Error} The function may terminate the process with `process.exit(1)` if critical
+ *                 errors occur, such as:
+ *                 - Invalid input file (not a .taylored file, or does not exist).
+ *                 - Failure to read the patch file or write encrypted/metadata files.
+ *                 It handles errors by logging to console and exiting, rather than throwing
+ *                 to be caught by the main CLI handler.
+ */
+export async function handleCreateTaysell(
+  tayloredFilePath: string,
+  priceInput: string | undefined,
+  descriptionInput: string | undefined,
+  cwd: string,
+): Promise<void> {
+  console.log(`Starting .taysell package creation for: ${tayloredFilePath}`);
+
+  // 1. Validate input .taylored file
+  if (!tayloredFilePath.endsWith(TAYLORED_FILE_EXTENSION)) {
+    console.error(
+      `CRITICAL ERROR: Input file must be a .taylored file. Received: ${tayloredFilePath}`,
+    );
+    process.exit(1);
+  }
+  const fullTayloredPath = path.resolve(cwd, tayloredFilePath);
+  if (!(await fs.pathExists(fullTayloredPath))) {
+    console.error(
+      `CRITICAL ERROR: Taylored file not found at: ${fullTayloredPath}`,
+    );
+    process.exit(1);
+  }
+  const patchFileNameBase = path.basename(tayloredFilePath);
+
+  // 2. Look for local backend configuration
+  const envPath = path.join(cwd, 'taysell-server', '.env');
+  const envConfig = await readEnvFile(envPath);
+
+  let {
+    SERVER_BASE_URL: serverBaseUrl,
+    PATCH_ENCRYPTION_KEY: patchEncryptionKey,
+    // Allow reading patchId from .env if users want to pre-define it, though typically it's per-patch
+    PATCH_ID: patchIdFromEnv,
+  } = envConfig;
+
+  const questions: any[] = []; // Use any[] to bypass QuestionCollection type issue in test
+  if (!serverBaseUrl) {
+    questions.push({
+      type: 'input',
+      name: 'serverBaseUrl',
+      message: 'Enter the SERVER_BASE_URL of your Taysell backend:',
+      validate: (input: string) =>
+        input.trim() !== '' || 'Server URL cannot be empty.',
+    });
+  }
+  if (!patchEncryptionKey) {
+    questions.push({
+      type: 'password',
+      name: 'patchEncryptionKey',
+      message: 'Enter the PATCH_ENCRYPTION_KEY for encrypting patches:',
+      validate: (input: string) =>
+        input.trim().length >= 32 ||
+        'Encryption key must be at least 32 characters.',
+    });
+  }
+
+  questions.push(
+    {
+      type: 'input',
+      name: 'patchName',
+      message: 'Enter the commercial name for this patch:',
+      default: patchFileNameBase.replace(TAYLORED_FILE_EXTENSION, ''),
+    },
+    {
+      type: 'input',
+      name: 'patchDescription',
+      message: 'Enter a description for this patch:',
+      default: descriptionInput || 'No description provided.',
+    },
+    {
+      type: 'input',
+      name: 'patchId',
+      message:
+        'Enter a unique ID for this patch (or press Enter to generate one):',
+      default: patchIdFromEnv || crypto.randomUUID(),
+    },
+    {
+      type: 'input',
+      name: 'tayloredVersion',
+      message: 'Enter the required taylored CLI version (e.g., >=6.8.21):',
+      default: '>=6.8.21',
+    }, // TODO: Read from current CLI version?
+    {
+      type: 'input',
+      name: 'price',
+      message: 'Enter the price (e.g., 9.99):',
+      default: priceInput,
+      validate: (input: string) =>
+        !isNaN(parseFloat(input)) || 'Invalid price.',
+    },
+    {
+      type: 'input',
+      name: 'currency',
+      message: 'Enter the currency code (e.g., USD, EUR):',
+      default: 'USD',
+      validate: (input: string) =>
+        input.trim().length === 3 || 'Currency code must be 3 letters.',
+    },
+  );
+  // Seller info
+  questions.push(
+    {
+      type: 'input',
+      name: 'sellerName',
+      message: 'Enter your seller name/company name:',
+      default: envConfig.SELLER_NAME || '',
+    },
+    {
+      type: 'input',
+      name: 'sellerWebsite',
+      message: 'Enter your seller website (URL):',
+      default: envConfig.SELLER_WEBSITE || '',
+    },
+    {
+      type: 'input',
+      name: 'sellerContact',
+      message: 'Enter your seller contact email:',
+      default: envConfig.SELLER_CONTACT || '',
+    },
+  );
+
+  let answers;
+
+  // Check if the code is running inside a Jest test worker
+  if (process.env.JEST_WORKER_ID) {
+    // If in a test, use default values instead of prompting
+    console.log('Running in test environment, skipping interactive prompts.');
+    answers = {
+      patchName: patchFileNameBase.replace(TAYLORED_FILE_EXTENSION, ''),
+      patchDescription: descriptionInput || 'Default test description',
+      patchId: patchIdFromEnv || crypto.randomUUID(),
+      tayloredVersion: '>=6.8.21',
+      price: priceInput || '0.00',
+      currency: 'USD',
+      sellerName: envConfig.SELLER_NAME || 'E2E Test Seller',
+      sellerWebsite: envConfig.SELLER_WEBSITE || 'https://example.com',
+      sellerContact: envConfig.SELLER_CONTACT || 'e2e@example.com',
+      // Also provide defaults for potentially missing env variables
+      serverBaseUrl: serverBaseUrl || 'http://test.com',
+      patchEncryptionKey:
+        patchEncryptionKey || 'a_default_test_key_that_is_32_characters_long',
+    };
+  } else {
+    // If not in a test, show the interactive prompts
+    answers = await inquirer.prompt(questions);
+  }
+
+  // Consolidate answers with envConfig
+  serverBaseUrl = serverBaseUrl || answers.serverBaseUrl;
+  patchEncryptionKey = patchEncryptionKey || answers.patchEncryptionKey;
+  const finalPatchId = answers.patchId;
+
+  console.log(`Using Patch ID: ${finalPatchId}`);
+  console.log(`Using Server Base URL: ${serverBaseUrl}`);
+
+  // 3. Encrypt the <file.taylored>
+  const patchContent = await fs.readFile(fullTayloredPath, 'utf-8');
+  const encryptedPatchContent = encryptAES256GCM(
+    patchContent,
+    patchEncryptionKey,
+  );
+  const encryptedFileName = `${patchFileNameBase}.encrypted`;
+  const encryptedFilePath = path.join(cwd, encryptedFileName); // Save in CWD for now
+  await fs.writeFile(encryptedFilePath, encryptedPatchContent);
+  console.log(`Patch encrypted successfully: ${encryptedFilePath}`);
+
+  // 4. Generate the .taysell file
+  const taysellFileContent = {
+    taysellVersion: '1.0-decentralized',
+    patchId: finalPatchId,
+    sellerInfo: {
+      name: answers.sellerName,
+      website: answers.sellerWebsite,
+      contact: answers.sellerContact,
+    },
+    metadata: {
+      name: answers.patchName,
+      description: answers.patchDescription,
+      tayloredVersion: answers.tayloredVersion,
+    },
+    endpoints: {
+      initiatePaymentUrl: `${serverBaseUrl}/pay/${finalPatchId}`, // Construct URL
+      getPatchUrl: `${serverBaseUrl}/get-patch`, // Construct URL
+    },
+    payment: {
+      price: answers.price,
+      currency: answers.currency.toUpperCase(),
+    },
+  };
+
+  const taysellFileName = `${patchFileNameBase.replace(TAYLORED_FILE_EXTENSION, '')}.taysell`;
+  const taysellJsonPath = path.join(cwd, taysellFileName);
+  await fs.writeJson(taysellJsonPath, taysellFileContent, { spaces: 2 });
+  console.log(`.taysell metadata file generated: ${taysellJsonPath}`);
+
+  // 5. Inform the seller
+  console.log(`
+--- Taysell Package Creation Complete ---`);
+  console.log(`  Encrypted Patch: ${encryptedFilePath}`);
+  console.log(`  Metadata File: ${taysellJsonPath}`);
+  console.log(`
+IMPORTANT: Upload the encrypted patch ('${encryptedFileName}') to your Taysell server's 'patches/' directory.`);
+  console.log(
+    `The .taysell file ('${taysellFileName}') is what you distribute to buyers.`,
+  );
+}
diff --git a/lib/handlers/setup-backend-handler.ts b/lib/handlers/setup-backend-handler.ts
new file mode 100644
index 0000000..166b401
--- /dev/null
+++ b/lib/handlers/setup-backend-handler.ts
@@ -0,0 +1,238 @@
+// lib/handlers/setup-backend-handler.ts
+import * as fs from 'fs-extra';
+import * as path from 'path';
+import inquirer from 'inquirer'; // Importa inquirer
+
+/**
+ * Implements the `taylored setup-backend` command functionality.
+ *
+ * This function guides the user through setting up the "Backend-in-a-Box" server,
+ * which is used for Taysell, the commercial patch distribution system. The setup
+ * process involves:
+ *
+ * 1. **Template Copying**: Locates the `backend-in-a-box` template within the Taylored
+ *    installation and copies it to a new `taysell-server/` directory in the current
+ *    working directory (`CWD`). If `taysell-server/` already exists, it prompts the
+ *    user for confirmation to overwrite (unless in a test environment).
+ * 2. **Interactive Configuration (via Inquirer)**: Prompts the user for essential
+ *    configuration details required for the backend server. These include:
+ *    - PayPal environment (`sandbox` or `production`).
+ *    - PayPal Client ID.
+ *    - PayPal Client Secret.
+ *    - PayPal Webhook ID.
+ *    - The public URL where the Taysell server will be accessible.
+ *    - A strong encryption key (at least 32 characters) for securing patches.
+ *    - The local port number for the backend server.
+ *    In test environments (when `process.env.JEST_WORKER_ID` is set), it bypasses
+ *    prompts and uses predefined test values.
+ * 3. **.env File Generation**: Creates a `.env` file in the `taysell-server/` directory,
+ *    populating it with the configuration values collected from the user (or test defaults).
+ *    This file is used by Docker Compose and the Node.js server to configure the backend.
+ * 4. **User Instructions**: Prints instructions to the console on how to build and run
+ *    the newly configured backend server using Docker Compose (recommended) and provides
+ *    guidance for next steps.
+ *
+ * For more details on the `taylored setup-backend` command and the "Backend-in-a-Box"
+ * features, refer to `DOCUMENTATION.md`.
+ *
+ * @async
+ * @param {string} cwd - The current working directory where the `taysell-server/`
+ *                       directory will be created.
+ * @returns {Promise<void>} A promise that resolves when the setup process is complete
+ *                          or if the user aborts the setup.
+ * @throws {Error} The function may terminate the process with `process.exit(1)` if
+ *                 critical errors occur, such as:
+ *                 - Failure to find the backend template source.
+ *                 - Inability to copy template files.
+ *                 - Failure to write the `.env` file.
+ *                 It doesn't explicitly throw errors to be caught by the caller in `index.ts`
+ *                 but rather handles them by exiting.
+ */
+export async function handleSetupBackend(cwd: string): Promise<void> {
+  console.log('Starting Taysell backend setup...');
+
+  const backendDestPath = path.join(cwd, 'taysell-server');
+
+  // 2. Copy "Backend-in-a-Box" template files
+  try {
+    const templateSourcePath = path.resolve(
+      __dirname,
+      '../../templates/backend-in-a-box',
+    );
+
+    if (!(await fs.pathExists(templateSourcePath))) {
+      console.error(
+        `CRITICAL ERROR: Backend template source directory not found at ${templateSourcePath}`,
+      );
+      process.exit(1);
+    }
+
+    if (await fs.pathExists(backendDestPath)) {
+      if (!process.env.JEST_WORKER_ID) {
+        const { overwrite } = await inquirer.prompt([
+          {
+            type: 'confirm',
+            name: 'overwrite',
+            message: `The directory ${backendDestPath} already exists. Do you want to overwrite its contents?`,
+            default: false,
+          },
+        ]);
+        if (!overwrite) {
+          console.log('Backend setup aborted by user.');
+          return;
+        }
+      }
+      await fs.emptyDir(backendDestPath);
+    } else {
+      await fs.ensureDir(backendDestPath);
+    }
+
+    await fs.copy(templateSourcePath, backendDestPath);
+    console.log(`Backend template files copied to ${backendDestPath}`);
+  } catch (error: any) {
+    console.error(
+      `CRITICAL ERROR: Could not copy backend template files. Details: ${error.message}`,
+    );
+    process.exit(1);
+  }
+
+  let answers;
+
+  // 3. Interactive configuration wizard
+  if (process.env.JEST_WORKER_ID) {
+    console.log('Running in test environment, using default config for .env');
+    answers = {
+      paypalEnv: 'sandbox',
+      paypalClientId: 'test-client-id',
+      paypalClientSecret: 'test-client-secret',
+      paypalWebhookId: 'test-webhook-id', // Aggiunto per i test
+      serverPublicUrl: 'https://test.example.com',
+      patchEncryptionKey: 'test-encryption-key-that-is-32-characters-long',
+      serverPort: '3001',
+    };
+  } else {
+    answers = await inquirer.prompt([
+      {
+        type: 'list',
+        name: 'paypalEnv',
+        message: 'Select PayPal environment:',
+        choices: ['sandbox', 'production'],
+      },
+      {
+        type: 'input',
+        name: 'paypalClientId',
+        message: 'Enter your PayPal Client ID:',
+        validate: (input) =>
+          input.trim() !== '' || 'Client ID cannot be empty.',
+      },
+      {
+        type: 'password',
+        name: 'paypalClientSecret',
+        message: 'Enter your PayPal Client Secret:',
+        validate: (input) =>
+          input.trim() !== '' || 'Client Secret cannot be empty.',
+      },
+      // Added prompt for Webhook ID
+      {
+        type: 'password',
+        name: 'paypalWebhookId',
+        message: 'Enter your PayPal Webhook ID:',
+        validate: (input) =>
+          input.trim() !== '' || 'Webhook ID cannot be empty.',
+      },
+      {
+        type: 'input',
+        name: 'serverPublicUrl',
+        message:
+          'Enter the public URL of your server (e.g., https://example.com):',
+        validate: (input) => {
+          if (input.trim() === '') return 'Server URL cannot be empty.';
+          try {
+            const url = new URL(input);
+            if (url.protocol !== 'https:' && url.protocol !== 'http:') {
+              return 'URL must start with http:// or https://';
+            }
+            return true;
+          } catch (_) {
+            return 'Invalid URL format.';
+          }
+        },
+      },
+      {
+        type: 'password',
+        name: 'patchEncryptionKey',
+        message:
+          'Enter a strong encryption key for your patches (at least 32 characters):',
+        validate: (input) =>
+          input.trim().length >= 32 ||
+          'Encryption key must be at least 32 characters long.',
+      },
+      {
+        type: 'input',
+        name: 'serverPort',
+        message:
+          'Enter the local port the backend server should run on (e.g., 3000):',
+        default: '3000',
+        validate: (input) => {
+          const port = parseInt(input, 10);
+          return (port > 0 && port < 65536) || 'Invalid port number.';
+        },
+      },
+    ]);
+  }
+
+  // 4. Write to .env file
+  const envContent = `
+# Node.js Environment
+NODE_ENV=production
+
+# Server Configuration
+SERVER_BASE_URL=${answers.serverPublicUrl}
+PORT=${answers.serverPort}
+
+# PayPal Configuration
+PAYPAL_ENVIRONMENT=${answers.paypalEnv}
+PAYPAL_CLIENT_ID=${answers.paypalClientId}
+PAYPAL_CLIENT_SECRET=${answers.paypalClientSecret}
+PAYPAL_WEBHOOK_ID=${answers.paypalWebhookId}
+
+# Patch Encryption
+PATCH_ENCRYPTION_KEY=${answers.patchEncryptionKey}
+
+# Database Configuration (SQLite)
+DB_PATH=./db/taysell.sqlite
+`;
+  const envPath = path.join(backendDestPath, '.env');
+  try {
+    await fs.writeFile(envPath, envContent.trim());
+    console.log(`Successfully created .env file at ${envPath}`);
+  } catch (error: any) {
+    console.error(
+      `CRITICAL ERROR: Could not write .env file at ${envPath}. Details: ${error.message}`,
+    );
+    process.exit(1);
+  }
+
+  // 5. Provide deployment instructions
+  if (!process.env.JEST_WORKER_ID) {
+    console.log('\\n--- Backend Setup Complete ---');
+    console.log(`Configuration written to ${envPath}`);
+    console.log(`Backend server files are in: ${backendDestPath}`);
+    console.log('\\nNext Steps:');
+    console.log('1. Navigate to the backend directory:');
+    console.log(`     cd ${path.relative(cwd, backendDestPath) || '.'}`);
+    console.log(
+      '2. Build and run the backend using Docker Compose (recommended) or manually:',
+    );
+    console.log('     docker-compose up --build -d  (for Docker)');
+    console.log(
+      `3. Your Taysell backend should be running and accessible via ${answers.serverPublicUrl} (if it maps to localhost:${answers.serverPort} or your server setup).`,
+    );
+    console.log(
+      '   Check Docker logs if you encounter issues: docker-compose logs -f',
+    );
+    console.log(
+      '\\nFor more details, refer to the "Backend-in-a-Box" documentation (included in taysell-server).',
+    );
+  }
+}
diff --git a/lib/taysell-utils.ts b/lib/taysell-utils.ts
new file mode 100644
index 0000000..e3c0ead
--- /dev/null
+++ b/lib/taysell-utils.ts
@@ -0,0 +1,222 @@
+// Copyright (c) 2025 tailot@gmail.com
+// SPDX-License-Identifier: MIT
+
+// lib/taysell-utils.ts
+import * as crypto from 'crypto';
+
+const ALGORITHM = 'aes-256-gcm';
+const IV_LENGTH = 16; // For GCM, 12 is recommended, but 16 is also common. Node uses 16 by default for IV generation if not specified.
+const SALT_LENGTH = 16;
+const KEY_LENGTH = 32; // AES-256
+const PBKDF2_ITERATIONS = 310000; // OWASP recommended minimum
+
+/**
+ * Encrypts text using AES-256-GCM.
+ * A random salt and IV are generated for each encryption.
+ * The salt, IV, and auth tag are prepended to the ciphertext.
+ * Key is derived from the password using PBKDF2.
+ * @param text The plaintext to encrypt.
+ * @param passwordKey The password to derive the key from.
+ * @returns A string in the format: salt:iv:authtag:ciphertext (all hex encoded).
+ */
+export function encryptAES256GCM(text: string, passwordKey: string): string {
+  const salt = crypto.randomBytes(SALT_LENGTH);
+  const iv = crypto.randomBytes(IV_LENGTH);
+
+  // Derive key using PBKDF2
+  const key = crypto.pbkdf2Sync(
+    passwordKey,
+    salt,
+    PBKDF2_ITERATIONS,
+    KEY_LENGTH,
+    'sha512',
+  );
+
+  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
+  let encrypted = cipher.update(text, 'utf8', 'hex');
+  encrypted += cipher.final('hex');
+  const tag = cipher.getAuthTag();
+
+  return `${salt.toString('hex')}:${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`;
+}
+
+/**
+ * Decrypts text encrypted with AES-256-GCM.
+ * Assumes salt, IV, and auth tag are prepended to the ciphertext.
+ * @param encryptedText The encrypted text in format salt:iv:authtag:ciphertext (all hex).
+ * @param passwordKey The password to derive the key from.
+ * @returns The decrypted plaintext.
+ * @throws Error if decryption fails (e.g., wrong key, tampered data).
+ */
+export function decryptAES256GCM(
+  encryptedText: string,
+  passwordKey: string,
+): string {
+  const parts = encryptedText.split(':');
+  if (parts.length !== 4) {
+    throw new Error(
+      'Invalid encrypted text format. Expected salt:iv:authtag:ciphertext',
+    );
+  }
+  const salt = Buffer.from(parts[0], 'hex');
+  const iv = Buffer.from(parts[1], 'hex');
+  const tag = Buffer.from(parts[2], 'hex');
+  const ciphertext = parts[3];
+
+  // Derive key using PBKDF2
+  const key = crypto.pbkdf2Sync(
+    passwordKey,
+    salt,
+    PBKDF2_ITERATIONS,
+    KEY_LENGTH,
+    'sha512',
+  );
+
+  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
+  decipher.setAuthTag(tag);
+  let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
+  decrypted += decipher.final('utf8');
+  return decrypted;
+}
+
+// Add other Taysell related utility functions here later (e.g., .taysell file validation)
+
+// Define interfaces for .taysell file structure (can be shared or defined here)
+export interface SellerInfo {
+  name: string;
+  website: string;
+  contact: string;
+}
+
+export interface PatchMetadata {
+  name: string;
+  description: string;
+  tayloredVersion: string;
+}
+
+export interface Endpoints {
+  initiatePaymentUrl: string;
+  getPatchUrl: string;
+}
+
+export interface PaymentInfo {
+  price: string;
+  currency: string;
+}
+
+export interface TaysellFile {
+  taysellVersion: string;
+  patchId: string;
+  sellerInfo: SellerInfo;
+  metadata: PatchMetadata;
+  endpoints: Endpoints;
+  payment: PaymentInfo;
+}
+
+/**
+ * Validates the structure and content of a parsed .taysell file object.
+ * @param data The parsed JSON object from a .taysell file.
+ * @returns The validated TaysellFile data.
+ * @throws Error if validation fails.
+ */
+export function validateTaysellFileContent(data: any): TaysellFile {
+  if (!data || typeof data !== 'object') {
+    throw new Error('Invalid .taysell file: content is not an object.');
+  }
+
+  const requiredFields = [
+    'taysellVersion',
+    'patchId',
+    'sellerInfo',
+    'metadata',
+    'endpoints',
+    'payment',
+  ];
+  for (const field of requiredFields) {
+    if (!data[field]) {
+      throw new Error(
+        `Invalid .taysell file: missing required field "${field}".`,
+      );
+    }
+  }
+
+  if (
+    typeof data.taysellVersion !== 'string' ||
+    data.taysellVersion !== '1.0-decentralized'
+  ) {
+    throw new Error(
+      `Invalid .taysell file: unsupported taysellVersion "${data.taysellVersion}". Expected "1.0-decentralized".`,
+    );
+  }
+  if (typeof data.patchId !== 'string' || !data.patchId.trim()) {
+    throw new Error(
+      'Invalid .taysell file: patchId must be a non-empty string.',
+    );
+  }
+
+  // SellerInfo validation
+  if (
+    typeof data.sellerInfo !== 'object' ||
+    !data.sellerInfo.name ||
+    typeof data.sellerInfo.name !== 'string'
+  ) {
+    throw new Error(
+      'Invalid .taysell file: sellerInfo.name is missing or not a string.',
+    );
+  }
+  // Add more checks for sellerInfo.website (URL format), sellerInfo.contact (email format) if desired
+
+  // Metadata validation
+  if (
+    typeof data.metadata !== 'object' ||
+    !data.metadata.name ||
+    typeof data.metadata.name !== 'string'
+  ) {
+    throw new Error(
+      'Invalid .taysell file: metadata.name is missing or not a string.',
+    );
+  }
+  // Add more checks for metadata.description, metadata.tayloredVersion (semver format)
+
+  // Endpoints validation
+  if (
+    typeof data.endpoints !== 'object' ||
+    !data.endpoints.initiatePaymentUrl ||
+    typeof data.endpoints.initiatePaymentUrl !== 'string' ||
+    !data.endpoints.getPatchUrl ||
+    typeof data.endpoints.getPatchUrl !== 'string'
+  ) {
+    throw new Error(
+      'Invalid .taysell file: endpoints.initiatePaymentUrl and endpoints.getPatchUrl must be non-empty strings.',
+    );
+  }
+  try {
+    new URL(data.endpoints.initiatePaymentUrl); // Validate URL format
+    const getPatchUrlObj = new URL(data.endpoints.getPatchUrl); // Validate URL format
+    if (getPatchUrlObj.protocol !== 'https:') {
+      throw new Error(
+        'Invalid .taysell file: endpoints.getPatchUrl must use HTTPS.',
+      );
+    }
+  } catch (e: any) {
+    throw new Error(
+      `Invalid .taysell file: one of the endpoint URLs is invalid. ${e.message}`,
+    );
+  }
+
+  // Payment validation
+  if (
+    typeof data.payment !== 'object' ||
+    !data.payment.price ||
+    typeof data.payment.price !== 'string' || // Assuming price as string e.g. "9.99"
+    !data.payment.currency ||
+    typeof data.payment.currency !== 'string' ||
+    data.payment.currency.length !== 3
+  ) {
+    throw new Error(
+      'Invalid .taysell file: payment.price must be a string and payment.currency must be a 3-letter string.',
+    );
+  }
+
+  return data as TaysellFile; // If all checks pass, cast and return
+}
